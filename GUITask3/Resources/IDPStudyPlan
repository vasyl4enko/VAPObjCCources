
2. UIKit

Читаем все время доку по UIView, UIWIndow, UIResponder, UIViewController
Код должен соответствовать: guides.idapgroup.com

// Лекция на тему:
1. UIView обзорно;
2. UIWindow обзорно;
3. UIApplication обзорно;
4. Описание возможностей видов:
- цвет;
- видимость;
- положение;
- transform;
- точка на экране и виртуальная точка;
- анимации;
- обработка касаний через перегрузку методов;
- обработка касаний через gesture recognizers;
5. Краткое пояснение, что за видами стоят CALayers;
6. Краткое пояснение, что такое MVC, сконцентрировацца именно на VC;
7. Краткий рассказ об UIViewController;
8. git + git-flow.
9. пояснить разницу между видами и контроллерами, расскзаать, что все непосредственные преобразования видов должны происходить в видах, а контроллер должен вызывать методы вида только
10. рассказать о том, какие есть опции анимации у видов

Задание 1.
1. Создать подкласс вида и забиндить его в интерфейс билдере через IBOutlet на общий вид контроллера;
2. Анимации должны быть реализованы в виде;
3. Добавить typedef состояний положений квадратика (четыре угла);
4. Создать проперти squarePosition для установления положения с сеттерами удовлетворяющими следующим требованиям:
- setSquarePosition, где бы устанавливалось значение из тайпдефа положений квадратика, и само положение квадратика менялось бы без анимации;
- setSquarePosition:animated: , в котором бы при animated = YES происходила анимация от текущего положения квадратика к положению, определяемому передаваемым параметром squarePosition;
- setSquarePosition:animated:completionHandler: , в котором бы при animated = YES происходила анимация от текущего положения квадратика к положению, определяемому передаваемым параметром squarePosition, а по завершении вызывался бы completionHandler;
- должен происходить проброс от более простого проперти в более сложное, вся логика должна быть реализована в setSquarePosition:animated:completionHandler:;
- новое состояние squarePosition должно быть установлено только по окончании анимации;
- если до окончания предыдущей анимации будет установлена новая анимация, то новая анимация должна начаться от текущего положения квадратика;
5. В контроллере создать динамическую проперти, возвращающую объект класса вида или nil;
6. Сделать метод, запускающий и останавливающий зацикленные переезды квадратика по четырем углам, используя методы вида.

// Лекция:
1. Модели (DCI не нужно пока), массивы моделей;
2. Таблицы, как они работают, модели переиспользования, какие возможности они предоставляют;
3. UIImage, UIImageView;
4. UILabel;
5. UINib;
6. NSAttributedString.

Задание 2.
Написать UI приложение в один вид:
1. Данные - рандомные данные строковые (сгенерированные в процессе первого старта приложения) + изображение (одно на все ячейки, считываемое из файловой системы);
2. Представление для данных - таблица;
3. В таблице должна присутствовать возможность пересортировывать строки, добавлять новые, заполненные рандомом и удалять старые;
4. Необходимо написать модель и модель массива, модель массива должна быть наблюдаемой и должна удовлетворять следующим требованиям:
- доступ по индексам;
- доступ по литералу индекса;
- работа как с моделями, так и с индексами моделей;
- возможность получить количество;
5. Необходимо создать конвенции по использованию методов и сами методы в определенных иерархиях классов с помощью категорий и общих абстрактных родителей для переиспользования в этом и других проектах, которые бы обеспечивали следующее:
- получение объекта с конкретным типом из ниба используя UINib;
- получение объекта с конкретным типом из ниба используя NSBundle;
- получение переиспользуемой ячейки из таблицы с конкретным типом;
- получение переиспользуемой ячейки из таблицы или создание новой в случае, когда переиспольземые ячейки недоступны с конкретным типом;
- создание окна с размерами, равными размеру экрана;
- создание нового вьюконтроллера с дефолтным именем ниба и нулевым бандлом;
- reuseIdentifier ячейки, завязанный на имя класса ячейки.
6. Требования к контроллеру:
- должен позволять установить модель извне (в случае данного приложения модель должны быть передана из AppDelegate), при этом необходимо учесть следующие ситуации при установке модели извне:
а. у контроллера еще не создан вид;
б. У контроллера создан вид.
- процесс добавления/удаления контроллера в качестве наблюдателя модели должен быть автоматизированным в пределах контроллера;
- процесс добавления и удаления ячейки должен быть анимированным через наблюдение за состоянием массива моделей.
7. Внешний вид всех видов, включая ячейки таблицы должен быть задан в нибах.

// Лекция:
1. Асинхронная загрузка;
2. Как асинхронно грузить все с наблюдением за состоянием загрузки;
3. Рассказать, о том, как грузить картинки и почему не нужен дял ячеек контроллер для каждой, а можно наблюдать за состоянием модели напрямую из ячейки.

Задание 3.
1. Сохранять состояние между запусками приложения используя NSCoding и сериализацию массива моделей в плист в файловой системе при следующих событиях:
- приложение уходит в бекграунд;
- приложение умирает;
2. Загружать состояние приложения асинхронно, сначала показав вид с загрузкой, а потом таблицу;
3. Вид загрузки должен отвечать следующим требованиям:
- должен уметь появляться и исчезать анимированно через изменение альфы;
- должен быть задан в отдельном нибе;
- должен иметь метод создания, который бы автоматически прикреплял его к какому-то виду;
- должен затемнять экран приложения;
4. Загружать картинку асинхронно в каждой из моделей ячеек, наблюдать из ячеек за состоянием модели и обновлять себя соответствующим образом (пока грузим - спиннер, загрузили - данные);
5. Создать абстрактную родительскую модель, отвечающую следующим требованиям:
- обеспечивает переход между потоками;
- дает точки перегрузки для бекграундной обработки загрузки;
- сгенерировано несколько typedef состояний, отвечающих за разные состояния загрузки модели;
- сгенерирован протокол нотификации наблюдателей о различных состояниях;
- есть методы для нотификации наблюдателей о разных состояниях модели;
- при загрузке уже загруженной модели повторная загрузка происходить не должна;
- при загрузке уже загруженной модели должна происходить нотификация о том, что модель загружена;
- нужно также учесть, что полноценной автоматизации всех переходов при обработке данных и нотификаций сделать не выйдет, т.к.операции могут быть не только синхронными (как в упражнении 7 первого блока) так и асинхронными, соответственно, добавить нужные возможности для завершения процесса обработки в наследниках класса;
6. Переработать модели так, чтобы они были унаследованы от абстрактной родительской модели.

// IDPKit -> IDPModel, IDPObservableObject

Задание 4.
1. Создать модель изображения, которая бы удовлетворяла следующим требованиям:
- должна получать при создании URL картинки;
- имя закешированного файла должно генерировацца из URL;
- путь файла должен генерировацца в отдельном методе;
- при вызове метода load, должна проверить, закешировано ли изображение и:
а. если не закешировано, то должна:
- должна асинхронно загрузить из интернета картинку;
- в бекграунде сохранить ее на жесткий диск;
- создать из данных, загруженных из интернета картинку;
- сообщить наблюдателям о том, что загрузилась;
б. если закешировано, то должна:
- загрузить картинку из файла, закешированного в файловой системе;
- сообщить наблюдателям о том, что загрузилась;
- при неконсистентности закешированного изображения должна удалить его и начать процесс загрузки из интернета
- при ошибке во время загрузки из интернета, должна нотифицировать наблюдателей об ошибке загрузки;
- должна иметь возможность отменить загрузку, что приводит к обнулению закачанных данных или изображения по факту загрузки;
2. Создать кеш моделей изображений, который должен удовлетворять следующим требованиям:
- должен быть потокобезопасным;
- должен хранить связки моделей изображения с урлами изображений;
- модели изображений должен хранить через слабые связи;
- должен быть синглтоном;
3. Интегрировать кеш изображений в модели изображений для того, чтобы гарантировать, что если у нас либо еще нет моделей, управляющих картинкой по данному урлу, либо она только одна и уникальна. При интеграции должно быть соблюдено следующее поведение:
- создается модель с определенным урлом и по этому урлу добавляется в кеш
- создается еще одна модель по тому же урлу, от нее надо избавится в ините и взамен вернуть модель из кеша;
- при деаллокации модель надо убрать из кеша;
4. Создать собственный Image View, который бы был оберткой над UIImageView и работал только с моделями изображений, описанными выше, при этом полностью отвечал за загрузки и анимации при загрузках;
5. Сделать выполнение всех блоков таковым, чтобы не хранились объекты, которые уже не нужны при диспатче (__weak, __strong).

// DCI, метод execute
// обяснить, что такое навигация, UITabBarViewController, UINavigationViewController

Задание 5.
1. Создать базовый контекст, который бы имел метод execute (выполнить), cancel (отменить);
2. Создать контекст логина в фейсбук;
3. Создать контекст загрузки в котором из фейсбука выкачиваются все друзья юзера (имя, фамилия, превьюшка фото пользователя) и по ним создать массив моделей для ячеек;
4. Проводить загрузку картинок в каждой из ячеек асинхронно по требованию ячейки;
5. Модель пользователей должна быть сериализована в плист аналогично заданию 3, пункт 1;
6. Если нет инета, то должны использоваться закешированные данные;
7. Если есть интернет, то закешированные данные должны выкачиваться из интернета, а прошлый кеш должен быть уничтожен и заменен на новый кеш;
8. Создать loginViewController с кнопкой loginToFacebook, по которой бы происходил логин в фейсбук;
9. Создать friendsViewCOntroller, показывающий таблицу друзей;
10. Создать friendDetailViewController, показывающий все инфу о друге (имя, город, страна и большая фота);
11. Для каждого из действий создать контексты, в частности для логина в фейсбук, вытягивания друзей, вытягивания детальной инфомрации о друге, причем необходимо, чтобы хранения для описания друга и детального описания использавалась одна и та же модель друга, в которую бы контексты инкрементально добавляли данные;
12. Добавить навигационный контроллер, для навигации между этими тремя контроллерами;
13. Общее поведение у контроллеров должно быть вынесено в абстрактного родителя.

Задание 6.
// обяснить, что такое композиция
// краткий экскурс в core data
// обяснить, что такое active record

1. Добавить кеширование в БД с использование IDPActiveRecord;
2. Добавить композицию в модели, для того, чтобы не ругалось на unrecognized selector, все миксины (объекты, которые мы используем для расширения поведения), должны иметь свой публичный интерфейс, как протокол, который надо принять объектом, с которым происходит композиция;
3. Модель массива должна следить за состоянием базы данных и себя соответствующим образом обновлять используя NSFetchedResultsController;
4. При логине должна быть следующая череда событий:
- пользователь логинится в соц.сеть;
- в бд происходит поиск данного пользователя по ID соц.сеть;
- если пользователя нет в БД, то он должен быть создан;
5. Если интернет доступен, то база данных не должна очищаться, а должна обновлять свои записи;
6. БД и логика работы с соц.сетью должна удовлетворять следующим требованиям:
- реализована множественная связь to-many в БД, которая бы определяла друзей пользователя;
- каждый пользователь с уникальным ID должен присутствовать в БД, как одна единственная запись;
- реализовать поиск уникального объекта по ID нужно реализовать в абстрактном родителе, унаследованном от NSManagedObject, от которого должны быть унаследованы уже все сущности, содержащие ID, как одно из полей;
- при этом осуществлять наследование в самой Core Data Managed Object Model (xcdatamodeld) строжайше запрещено;
7. В детальном виде пользователя должна присутствовать возможность перейти в список список фотографий пользователя этого;
8. Каждый из видов (список друзей, детальный вид друга, список фоток) должен позволять выполнять pull to refresh с использованием open source решения;
9. Общее поведение контроллеров таблиц должно быть вынесено в абстрактного родителя.

Задание 7.
// Core Graphics
// Core Location
// UITabBarViewController

1. Создать приложение - компас с UITabBarViewController в качестве рутового вью контроллера со следующими табами:
- Map;
- Location;
- Compass;
2. Вид карты должен показывать карту, на которой бы было отображено текущее положение пользователя и три булавки на расстоянии 100м, 500м и 1км (можете взять любые другие расстояния) от положения пользователя, причем при изменении положения пользователя, булавки должны перемещаться вслед за ним.
3. Положение должно содержать в себе кнопку "Inverse Geocode Current Location", при нажатии на которую на лейбле под кнопкой был бы отображен адрес текущего положения пользователя, причем, она должна быть автоматически отресайзена таким образом (с переносами на следующую строку), чтобы положение в любом случае вместилось на экран;
4. Компасс должен содержать следующие UI элементы:
- вид компаса, отвечающий следующим требованиям:
а. должны быть отображены насечки и стрелочка направления, нарисованные программно;
б. должен отбрасывать круговую тень (т.е. равномерно во все стороны от центра круга);
в. должны быть отображены стороны света, полученные с помощью афинных преобразований UILabel;
г. должна присутствовать возможность анимированно закрутить на любое количество оборотов, причем, когда закрутка окончена, он должен открутиться назад на текущее положение с тем же количеством оборотов, на которые была произведена закрутка;
- UISegmentedControl с сегментами "Start" и "Stop", по нажатию на состояние компасс начинает или прекращает действовать.
